{"./":{"url":"./","title":"Introduction","keywords":"","body":"大数据学习笔记 hadoop hive spark flink "},"flink/basic/1简介.html":{"url":"flink/basic/1简介.html","title":"1.1Flink简介","keywords":"","body":"一 flink是什么二 为什么选择 Flink哪些行业需要处理流数据三 数据处理的演变过程1.事务处理2.数仓ETL3.有状态的流(批)处理4.lambda架构:二代流处理5.flink:三代流处理四 Flink主要特点1.事件驱动2.基于流的世界观3.分层API4.其他特点五 Spark VS Flink六 Flink快速上手1.Maven工程2.批处理3.流处理• Flink 是什么 • 为什么要用 Flink • 流处理的发展和演变 • Flink 的主要特点 • Flink vs Spark Streaming 一 flink是什么 Apache Flink 是一个框架和分布式处理引擎，用于对无界和有界数 据流进行状态计算。 二 为什么选择 Flink • 流数据更真实地反映了我们的生活方式 • 传统的数据架构是基于有限数据集的 • 我们的目标 ➢ 低延迟 ➢ 高吞吐 ➢ 结果的准确性和良好的容错性 哪些行业需要处理流数据 • 电商和市场营销 ➢ 数据报表、广告投放、业务流程需要 • 物联网（IOT） ➢ 传感器实时数据采集和显示、实时报警，交通运输业 • 电信业 ➢ 基站流量调配 • 银行和金融业 ➢ 实时结算和通知推送，实时检测异常行为 三 数据处理的演变过程 1.事务处理 将数据保存到关系型数据库(mysql),在通过关联连接查询进行统计分析 2.数仓ETL 将数据从业务数据库复制到数仓，再进行分析和查询 3.有状态的流(批)处理 第一批流式处理 通过一个本地内存中local state变量来保存数据,当有数据到大,就更新该状态 缺点:无法保证数据的顺序性 4.lambda架构:二代流处理 ➢ 用两套系统，同时保证低延迟和结果准确 一套批处理,一套流处理 最后将批处理表和流处理表相结合,得到相关结果 缺点:要做两套系统,过于麻烦 5.flink:三代流处理 四 Flink主要特点 1.事件驱动 左边为传统事务型处理 右边为flink的架构 二者非常相似,都是来一个事件,处理一个事件 2.基于流的世界观 ➢ 在 Flink 的世界观中，一切都是由流组成的，离线数据是有界的流；实时数据是一个没有界限的流：这就是所谓的有界流和无界流 对于无界流数据,来一个处理一个(和批处理最大的不同) 对于有界流(离线)数据,可以等到一个临界点,一起同时处理 3.分层API ➢ 越顶层越抽象，表达含义越简明，使用越方便 ➢ 越底层越具体，表达能力越丰富，使用越灵活 最上层Table API,可以自行撰写SQL语句 中层Stream Api,可以进行流或批处理 最底层Api,不仅能获得事件,状态,还能获取事件,是最灵活,也是最复杂的Api 4.其他特点 • 支持事件时间（event-time）和处理时间（processing-time）语义 • 精确一次（exactly-once）的状态一致性保证 • 低延迟，每秒处理数百万个事件，毫秒级延迟 • 与众多常用存储系统的连接 • 高可用，动态扩展，实现7*24小时全天候运行 五 Spark VS Flink 本质上流处理和批处理的过程 spark的本质还是攒一批后处理,会有延迟 flink的本质是流处理,来一个处理一个,延迟极低 • 数据模型 – spark 采用 RDD 模型，spark streaming 的 DStream 实际上也就是一组 组小批数据 RDD 的集合 – flink 基本数据模型是数据流，以及事件（Event）序列 • 运行时架构 – spark 是批计算，将 DAG 划分为不同的 stage，一个完成后才可以计算下一个 也即若有一个节点没处理完,后面的就不能做 – flink 是标准的流执行模式，一个事件在一个节点处理完后可以直接发往下一个节 点进行处理 六 Flink快速上手 1.Maven工程 pom.xml org.apache.flink flink-java 1.10.1 org.apache.flink flink-streaming-java_2.12 1.10.1 2.批处理 public class PiWordCount { public static void main(String[] args) throws Exception { //执行环境 ExecutionEnvironment env= ExecutionEnvironment.getExecutionEnvironment(); // 从文件中读取数据 String inputPath= \"file/word.txt\"; DataSet inputDataSet = env.readTextFile(inputPath); // 空格分词打散之后，对单词进行 groupby 分组，然后用 sum 进行聚合 DataSet> sum = inputDataSet. flatMap(new MyFlatMapper()). groupBy(0). sum(1); //打印 sum.print(); } public static class MyFlatMapper implements FlatMapFunction> { @Override public void flatMap(String value, Collector> collector) throws Exception { String[] words= value.split(\" \"); for(String word:words) { collector.collect(new Tuple2(word,1)); } } } } 3.流处理 通过socket发送单词: public class LiuWordCount { public static void main(String[] args) throws Exception { StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment(); DataStreamSource text = env.socketTextStream(\"localhost\", 9000); DataStream> wordCountDataStream=text. flatMap(new MyFlatMapper()). keyBy(0). sum(1); wordCountDataStream.print().setParallelism(1); env.execute(); } public static class MyFlatMapper implements FlatMapFunction> { @Override public void flatMap(String value, Collector> collector) throws Exception { String[] words= value.split(\" \"); for(String word:words) { collector.collect(new Tuple2(word,1)); } } } } 在cmd中输入:(建立socket连接) nc -l - p 9000 "},"flink/basic/2.运行架构.html":{"url":"flink/basic/2.运行架构.html","title":"1.2运行架构","keywords":"","body":"一 运行时组件1.JobManager2.TaskManager3.ResourceManager4.Dispatcher二 任务提交流程三 任务调度原理1.问题思考2.TaskManager与Slots3.程序与数据流4.执行图5.任务间数据传输形式6.任务链一 运行时组件 1.JobManager 控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的 JobManager 所控制执行。 JobManager 会先接收到要执行的应用程序，这个应用程序会包括：作业图 （JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、 库和其它资源的JAR包。 JobManager 会把JobGraph转换成一个物理层面的数据流图，这个图被叫做 “执行图”（ExecutionGraph），包含了所有可以并发执行的任务。 JobManager 会向资源管理器（ResourceManager）请求执行任务必要的资源， 也就是申请任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的 资源，就会将执行图分发到真正运行它们的TaskManager上。 而在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点（checkpoints） 的协调。 2.TaskManager Flink中的工作进程。通常在Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能够执行的任务数量。 启动之后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给JobManager调用。JobManager就可以向插槽分配任务（tasks）来执行了。 在执行过程中，一个TaskManager可以跟其它运行同一应用程序的TaskManager交换数据。 3.ResourceManager 主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManger 插槽是Flink中定义的处理资源单元。 Flink为不同的环境和资源管理工具提供了不同资源管理器，比如YARN、Mesos、K8s，以及standalone部署。 当JobManager申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给JobManager。如果ResourceManager没有足够的插槽来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器。 4.Dispatcher 可以跨作业运行，它为应用提交提供了REST接口。 当一个应用被提交执行时，分发器就会启动并将应用移交给一个 JobManager。 Dispatcher也会启动一个Web UI，用来方便地展示和监控作业 执行的信息。 Dispatcher在架构中可能并不是必需的，这取决于应用提交运行 的方式。 二 任务提交流程 我们来看看当一个应用提交执行时，Flink 的各个组件是如何交互协作的： 上图是从一个较为高层级的视角，来看应用中各组件的交互协作。如果部署的集群环境不同（例如 YARN，Mesos，Kubernetes，standalone 等），其中一些步骤可以被省略，或是有些组件会运行在同一个 JVM 进程中。 具体地，如果我们将 Flink 集群部署到 YARN 上，那么就会有如下的提交流程： Flink 任务提交后， Client 向 HDFS 上传 Flink 的 Jar 包和配置， 之后向 Yarn ResourceManager 提交任务， ResourceManager 分配 Container 资源并通知对应的NodeManager 启动 ApplicationMaster， ApplicationMaster 启动后加载 Flink 的 Jar 包和配置构建环境，然后启动 JobManager，之后 ApplicationMaster 向 ResourceManager 申请资源启动 TaskManager ， ResourceManager 分配 Container 资 源 后 ， 由ApplicationMaster 通 知 资 源 所 在 节 点 的 NodeManager 启动 TaskManager ， NodeManager 加载 Flink 的 Jar 包和配置构建环境并启动 TaskManager，TaskManager 启动后向 JobManager 发送心跳包， 并等待 JobManager 向其分配任务。 三 任务调度原理 客户端不是运行时和程序执行 的一部分，但它用于准备并发送dataflow(JobGraph)给 Master(JobManager)， 然后， 客户端断开连接或者维持连接以等待接收计算结果。 当 Flink 集 群 启 动 后 ， 首 先 会 启 动 一 个 JobManger 和一个或多个的TaskManager。由 Client 提交任务给 JobManager， JobManager 再调度任务到各个TaskManager 去执行， 然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。 *Client* 为提交 Job 的客户端，可以是运行在任何机器上（ 与 JobManager 环境连通即可）。提交 Job 后， Client 可以结束进程（ Streaming 的任务），也可以不结束并等待结果返回。 *JobManager* 主要负责调度 Job 并协调 Task 做 checkpoint ， 职责上很像Storm 的 Nimbus。从 Client 处接收到 Job 和 JAR 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。 *TaskManager* 在启动的时候就设置好了槽位数（ Slot），每个 slot 能启动一个Task， Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。 1.问题思考 怎样实现并行计算？ 多线程,涉及资源分配 并行的任务，需要占用多少slot？ 一个流处理程序，到底包含多少个任务？ 2.TaskManager与Slots 一个特定算子的 子任务（subtask）的个数被称之为其并行度（parallelism）。 一般情况下，一个 stream 的并行度，可以认为就是其所有算子中最大的并行度。 简单理解就是将任务一分为n,利用多线程并行计算 而子任务是运行在slot上的,也即和slot密不可分 Flink 中每一个 TaskManager 都是一个JVM进程，它可能会在独立的线程上执 行一个或多个子任务 为了控制一个 TaskManager 能接收多少个 task， TaskManager 通过 task slot 来进行控制（一个 TaskManager 至少有一个 slot） 一般将slot的数量设置为CPU的核心数量,以真正达到并行运算. slot共享 默认情况下，Flink 允许子任务共享 slot，即使它们是不同任务的子任务（前提是它们来自同一个 job）。 这样的结果是，一个 slot 可以保存作业的整个管道(pipeline)。 并行度设置 Task Slot是静态的概念， 是指TaskManager具有的并发执行能力\\， 可以通过参数 taskmanager.numberOfTaskSlots 进行配置；而并行度parallelism是动态概念， 即TaskManager运行程序时实际使用的并发能力，可以通过参数 parallelism.default 进行配置。 也就是说，假设一共有 3 个 TaskManager， 每一个 TaskManager 中的分配 3 个TaskSlot，也就是每个 TaskManager 可以接收 3 个 task，一共 9 个 TaskSlot，如果我们设置 parallelism.default=1，即运行程序默认的并行度为 1，9 个 TaskSlot 只用了 1 个，有 8 个空闲， 因此， 设置合适的并行度才能提高效率。 3.程序与数据流 所有的 Flink 程序都是由三部分组成的： Source、Transformation 和Sink。 Source 负责读取数据源， Transformation 利用各种算子进行处理加工， Sink 负责输出。 在运行时，Flink 上运行的程序会被映射成“ 逻辑数据流”（ dataflows），它包含了这三部分。每一个 dataflow 以一个或多个 sources 开始以一个或多个 sinks 结束。dataflow 类似于任意的有向无环图（ DAG）。在大部分情况下，程序中的转换运算（ transformations） 跟 dataflow 中的算子（ operator） 是一一对应的关系，但有时候，一个 transformation 可能对应多个 operator。 如下图,典型的有向无环图DAG 4.执行图 • Flink 中的执行图可以分成四层：StreamGraph -> JobGraph -> ExecutionGraph -> 物理执行图 ➢ StreamGraph：是根据用户通过 Stream API 编写的代码生成的最初的图。用来 表示程序的拓扑结构。 ➢ JobGraph：StreamGraph经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。主要的优化为，将多个符合条件的节点 chain 在一起作为一个节点 ➢ ExecutionGraph：JobManager 根据 JobGraph 生成ExecutionGraph。 ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构。 ➢ 物理执行图：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个 TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。 5.任务间数据传输形式 • 一个程序中，不同的算子可能具有不同的并行度 • 算子之间传输数据的形式可以是 one-to-one (forwarding) 的模式也可以是 redistributing 的模式，具体是哪一种形式，取决于算子的种类 ➢ One-to-one：stream维护着分区以及元素的顺序（比如source和map之间）。 这意味着map 算子的子任务看到的元素的个数以及顺序跟 source 算子的子任务 生产的元素的个数、顺序相同。map、fliter、flatMap等算子都是one-to-one 的对应关系。 ➢ Redistributing：stream的分区会发生改变。每一个算子的子任务依据所选择的 transformation发送数据到不同的目标任务。例如，keyBy 基于 hashCode 重 分区、而 broadcast 和 rebalance 会随机重新分区，这些算子都会引起 redistribute过程，而 redistribute 过程就类似于 Spark 中的 shuffle 过程。 6.任务链 • Flink 采用了一种称为任务链的优化技术，可以在特定条件下减少本地 通信的开销。为了满足任务链的要求，必须将两个或多个算子设为相同 的并行度，并通过本地转发（local forward）的方式进行连接 • 相同并行度的 one-to-one 操作，Flink 这样相连的算子链接在一起形 成一个 task，原来的算子成为里面的 subtask • 并行度相同、并且是 one-to-one 操作，两个条件缺一不可 "}}